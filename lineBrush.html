<!DOCTYPE html>
<meta charset="utf-8">
<style>

body {
    background: #eee;
    margin: 0 auto;
}

.card {
    margin: 30px auto;
    display: block;
    background: #fff;
    text-align: center;
    border-radius: 2px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);
    cursor: move;
}

.buttons {
    width: 50%;
    padding: 30px;
}

.buttons button {
    color: #6ec6ff;
    border: none;
    border-radius: 4px;
    font-size: 16px;
}

.line {
    fill: none;
    stroke: url(#line-gradient);
    stroke-width: 4px;
}

.toolTip {
    position: absolute;
    font-family: Helvetica;
    width:  220px;
    height: auto;
    pointer-events: none;
    background-color: #fff;
    border-radius: 2px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);
    display: grid;
    grid-template-columns: 1fr 2fr;
    
}

.toolTip__date {
    font-style:oblique;
    text-align: right;
    padding: 25px;
}

.toolTip__risk {
    /* margin-top: 5px; */
    font-style: italic;
    background: #f44336;
    font-size: 10px;
    text-align: center;
    padding-top: 5px;
} 

.toolTip__risk--value {
    font-style: normal;
    font-size: 36px;
    color: black;
    padding: 0 5px;
}

.axis path {
    stroke: #6ec6ff;
    stroke-width: 4px;
    shape-rendering:crispEdges;
}

.axis text {
    stroke: black;
    stroke-width: 0px;
    font-size: 14px;
    text-align: left;
}

.axis-label {
    font-size: 18px;
    stroke: #2196f3;
    fill: #2196f3;
}
.zoom {
  cursor: move;
  fill: none;
  pointer-events: all;
}

</style>
<body>
<svg width="960" height="600"></svg>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script>

var svg = d3.select("svg"),
    margin = {top: 20, right: 20, bottom: 110, left: 40},
    margin2 = {top: 520, right: 20, bottom: 30, left: 40},
    width = +svg.attr("width") - margin.left - margin.right,
    height = +svg.attr("height") - margin.top - margin.bottom,
    height2 = +svg.attr("height") - margin2.top - margin2.bottom;

var parsedate = d3.timeParse("%m/%d/%Y %H:%M");

const colors = {
    'green': '#4caf50',
    'yellow': '#fff176',
    'red': '#f44336'
} 


// set the scales for each graph.  same for each, just height is different on smaller graph
var x = d3.scaleTime().range([0, width]),
    x2 = d3.scaleTime().range([0, width]),
    y = d3.scaleLinear().range([height, 0]),
    y2 = d3.scaleLinear().range([height2, 0]);

// label the axes, need 2 x's since the top one will change, but no second y axis on the bottom
var xAxis = d3.axisBottom(x),
    xAxis2 = d3.axisBottom(x2),
    yAxis = d3.axisLeft(y);

// introduce 1Dimenional brush just on X axis
var brush = d3.brushX()
    .extent([[0, 0], [width, height2]])
    .on("brush end", brushed);

// introduce zoom
var zoom = d3.zoom()
    .scaleExtent([1, Infinity])
    .translateExtent([[0, 0], [width, height]])
    .extent([[0, 0], [width, height]])
    .on("zoom", zoomed);

// top line graph
var line = d3.line()
    .x(function (d) { return x(d.date); })
    .y(function (d) { return y(d.risk); });

// bottom line graph
var line2 = d3.line()
    .x(function (d) { return x2(d.date); })
    .y(function (d) { return y2(d.risk); });

//make only the needed SVG visible
var clip = svg.append("defs").append("svg:clipPath")
    .attr("id", "clip")
    .append("svg:rect")
    .attr("width", width)
    .attr("height", height)
    .attr("x", 0)
    .attr("y", 0); 

//append the top clip path to the svg, give it the clip path attribute linked to the clip element above
var graph = svg.append("g")
    .attr("class", "focus")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")")
    .attr("clip-path", "url(#clip)");

// append the top chart
var focus = svg.append("g")
    .attr("class", "focus")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

// append the bottom chart
var context = svg.append("g")
    .attr("class", "context")
    .attr("transform", "translate(" + margin2.left + "," + margin2.top + ")");

d3.json("http://maps.calsurv.org/zika/risk/Fresno", function (error, data) {
  if (error) throw error;

  data.forEach( (d) => {
      d.date = new Date(d[0]);
      d.risk = +d[1];
      console.log(d);
  })

  console.log(data);

  x.domain(d3.extent(data, function(d) { return d.date; }));
  y.domain([0, d3.max(data, function (d) { return d.risk; })]);
  x2.domain(x.domain());
  y2.domain(y.domain());

  graph.append("linearGradient")
        .attr("id", "line-gradient")
        .attr("gradientUnits", "userSpaceOnUse")
        .attr("x1", 0).attr("y1", y(0))
        .attr("x2", 0).attr("y2", y(3))
        .selectAll("stop")
        .data([
            {offset: "0%", color: colors['green']},
            {offset: "46%", color: colors["green"]},
            {offset: "46%", color: colors["yellow"]},
            {offset: "84%", color: colors["yellow"]},
            {offset: "84%", color: colors["red"]},
            {offset: "100%", color: colors["red"]}
        ])
        .enter().append("stop")
        .attr("offset", function(d) { return d.offset; })
        .attr("stop-color", function(d) { return d.color; });

    // append the x axis for the top chart
    focus.append("g")
        .attr("class", "axis axis--x")
        .attr("transform", "translate(0," + height + ")")
        .call(xAxis);

    // append the y axis for the top chart
    focus.append("g")
        .attr("class", "axis axis--y")
        .call(yAxis);

    // append the path with its data to the clipPath container
    graph.append("path")
        .datum(data)
        .attr("class", "line")
        .attr("d", line);

    graph.append('g')
                    .attr('class', 'dots')
                    .selectAll('.dots')
                        .data(data)
                        .enter()
                        .append('circle')
                        .attr('cx', (d) => x(d.date))
                        .attr('cy', (d) => y(d.risk))
                        .attr('r', 1)
                        .attr('fill', 'white')
                        .attr('stroke', 'black');

    // bottom chart gets same path
    context.append("path")
        .datum(data)
        .attr("class", "line")
        .attr("d", line2);

    // bottom chart gets x axis with xAxis2
    context.append("g")
        .attr("class", "axis axis--x")
        .attr("transform", "translate(0," + height2 + ")")
        .call(xAxis2);

    // big gray brush element is applied to the bottom chart
    context.append("g")
        .attr("class", "brush")
        .call(brush)
        .call(brush.move, x.range());

    // allows zooming directly over the chart using the mouse scroll, add a zoom rectangle rectangle over the whole chart
    svg.append("rect")
        .attr("class", "zoom")
        .attr("width", width)
        .attr("height", height)
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")")
        .call(zoom);


  console.log(data);
});

function brushed() {
  if (d3.event.sourceEvent && d3.event.sourceEvent.type === "zoom") return; // ignore brush-by-zoom
  var s = d3.event.selection || x2.range();
  x.domain(s.map(x2.invert, x2));
  graph.select(".line").attr("d", line);
  graph.selectAll('circle')
            .attr('cx', (d) => x(d.date))
            .attr('cy', (d) => y(d.risk));
  focus.select(".axis--x").call(xAxis);
  svg.select(".zoom").call(zoom.transform, d3.zoomIdentity
      .scale(width / (s[1] - s[0]))
      .translate(-s[0], 0));
}

function zoomed() {
  if (d3.event.sourceEvent && d3.event.sourceEvent.type === "brush") return; // ignore zoom-by-brush
  var t = d3.event.transform;
  x.domain(t.rescaleX(x2).domain());
  graph.select(".line").attr("d", line);
  focus.select(".axis--x").call(xAxis);
  context.select(".brush").call(brush.move, x.range().map(t.invertX, t));
  graph.selectAll('circle')
            .attr('cx', (d) => x(d.date))
            .attr('cy', (d) => y(d.risk));
}

// function type(d) {
//   d.date = new Date(d[0]);
//   d.risk = +d[1];
//   return d;
// }

</script>

</body>